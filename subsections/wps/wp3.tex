Software managers want to know several additional statistics and features about the fixes to help them manage and understand their code, over and above what is provided for by WP1 and WP2. Investigating and developing these statistics and features will be the project of WP3. We divide the project into a \textit{quantitive} sub-project, and \textit{qualitative} sub-project, as follows.

We first discuss the quantitive sub-project. This will include finding appropriate statistical measures for quantities of interest to a software manager, and developed as a function of the time series of error-causing propensities developed in WP1 and WP2. Basic statistics which answer the following questions will be of value, and can be decomposed into descriptive statistics (which describe how code development has behaved in the past) and, where possible, predictive statistics (which forecast how code development will continue in the future). Questions that can be given a statistical answer here include (but are not limited to) i) how many (or what is the rate of) fixes (or new bugs) which have taken place (or are to be expected) over a given time period, ii) what's the expected likelihood a type of bug will recur, iii) how many times has a fix been attempted for a given method, how many have worked, vi) how stable is the development of the code overall. Accordingly, in the first part of the workpackage we will develop and investigate these statistical measures. We expect these measures to fall within a range of elementary measures, to more sophisticated ones.  

We now discuss the qualitative sub-project. 
This includes correctly classifying a given fix into its fix type. This involves i) correct bug classification (to know what bug was fixed), ii) correctly associating each fix with a bug, and iii) the type of fix repaired the bug.
WP1 and WP2 solve ii), and methods exist at bug classification to help solve i), and can involve test mining engineering reports, or testing of the program before and after the given fix~\cite{6245635}. However, to our knowledge no work has been done at iii). Here, we (at least) want to know whether the fix fixed the bug in an efficient/inefficient, effective/ineffective, syntactically simple/complex way; paving the way for a large dictotomy table of different types of fix. For instance, a fix may have added an undue amount of runtime to a project, may have only been effective at solving a certain proportion of failures, and may involve a lot of complex code involving the addition of pointers or other new types of structures to the code. Any project manager will want to know the classes of this sort to which a fix belongs.  

